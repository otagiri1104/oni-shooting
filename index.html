<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Oni Shooting</title>
<style>
  body {
    margin: 0;
    background: #111;
  }
  canvas {
    display: block;
    margin: auto;
    background: #000;
  }
</style>
</head>
<body>

<canvas id="game" width="400" height="600"></canvas>

<script>
/* ===== Canvas ===== */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

/* ===== 画像読み込み ===== */
const oniImage = new Image();
oniImage.src = "teki.png";

const hukuImage = new Image();
hukuImage.src = "huku.png";

const playerImage = new Image();
playerImage.src = "onigiri.png";

/* ===== ゲーム状態 ===== */
let timeLeft = 30;
let score = 0;
let gameOver = false;

/* ===== プレイヤー ===== */
const player = {
  x: canvas.width / 2,
  y: canvas.height - 50,
  width: 48,
  height: 48,
  speed: 5
};

/* ===== 配列 ===== */
let bullets = [];
let enemies = [];

/* ===== 敵出現管理 ===== */
let spawnInterval = 1000;
let lastSpawnTime = 0;

/* ===== 入力 ===== */
const keys = {};
document.addEventListener("keydown", e => {
  keys[e.code] = true;
  if (e.code === "Space") shoot();
});
document.addEventListener("keyup", e => {
  keys[e.code] = false;
});

/* ===== 弾 ===== */
function shoot() {
  bullets.push({
    x: player.x,
    y: player.y - player.height / 2,
    radius: 4,
    speed: 7
  });
}

/* ===== 敵生成 ===== */
function spawnEnemy() {
  const isHuku = Math.random() < 0.1; // 10%でhuku

  enemies.push({
    x: Math.random() * (canvas.width - 40) + 20,
    y: -40,
    width: 48,
    height: 48,
    speed: 1.5 + score / 1500,
    type: isHuku ? "huku" : "normal"
  });
}

/* ===== 更新 ===== */
function update(time) {
  if (gameOver) return;

  /* プレイヤー移動 */
  if (keys["ArrowLeft"] && player.x > player.width / 2) {
    player.x -= player.speed;
  }
  if (keys["ArrowRight"] && player.x < canvas.width - player.width / 2) {
    player.x += player.speed;
  }

  /* 弾移動 */
  bullets.forEach(b => b.y -= b.speed);
  bullets = bullets.filter(b => b.y > -10);

  /* 敵移動 */
  enemies.forEach(e => e.y += e.speed);

  /* 敵が下に到達 */
  enemies = enemies.filter(e => {
    if (e.y > canvas.height + 20) {
      // hukuは時間ペナルティなし
      if (e.type !== "huku") {
        timeLeft -= 1;
      }
      return false;
    }
    return true;
  });

  /* 当たり判定 */
  bullets.forEach((b, bi) => {
    enemies.forEach((e, ei) => {
      if (
        b.x > e.x - e.width / 2 &&
        b.x < e.x + e.width / 2 &&
        b.y > e.y - e.height / 2 &&
        b.y < e.y + e.height / 2
      ) {
        // hukuに当てたら即ゲームオーバー
        if (e.type === "huku") {
          gameOver = true;
          return;
        }

        // 通常敵
        bullets.splice(bi, 1);
        enemies.splice(ei, 1);
        score += 100;
        timeLeft += 1;
      }
    });
  });

  /* 敵出現 */
  if (time - lastSpawnTime > spawnInterval) {
    spawnEnemy();
    lastSpawnTime = time;
  }

  /* ゲームオーバー */
  if (timeLeft <= 0) {
    gameOver = true;
  }
}

/* ===== 描画 ===== */
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  /* プレイヤー */
  ctx.drawImage(
    playerImage,
    player.x - player.width / 2,
    player.y - player.height / 2,
    player.width,
    player.height
  );

  /* 弾 */
  ctx.fillStyle = "yellow";
  bullets.forEach(b => {
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
    ctx.fill();
  });

  /* 敵 */
  enemies.forEach(e => {
    const img = e.type === "huku" ? hukuImage : oniImage;
    ctx.drawImage(
      img,
      e.x - e.width / 2,
      e.y - e.height / 2,
      e.width,
      e.height
    );
  });

  /* UI */
  ctx.fillStyle = "white";
  ctx.font = "16px sans-serif";
  ctx.textAlign = "left";
  ctx.fillText(`TIME: ${timeLeft}`, 10, 20);
  ctx.fillText(`SCORE: ${score}`, 10, 40);

  /* GAME OVER */
  if (gameOver) {
    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = "white";
    ctx.font = "28px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2 - 10);
    ctx.font = "20px sans-serif";
    ctx.fillText(`SCORE: ${score}`, canvas.width / 2, canvas.height / 2 + 25);
  }
}

/* ===== ループ ===== */
function loop(time) {
  update(time);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ===== 制限時間 ===== */
setInterval(() => {
  if (!gameOver) timeLeft -= 1;
}, 1000);
</script>

</body>
</html>
